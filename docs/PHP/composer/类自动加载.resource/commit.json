{"compress":true,"commitItems":[["f3529871-852b-4011-b4ce-79f5e8b83ad0",1652874098092,"",[[1652874092786,["mac@macdeMacBook-Pro.local",[[1,0,"# 类自动加载\n\n\n\n"]],[0,0],[10,10]]],[1652874097722,["mac@macdeMacBook-Pro.local",[[1,2,"起源\n很多开发者写面向对象的应用程序时，对每个"],[1,3,"的定义建立一个 PHP 源文件。一个很大的烦恼是不得不在每个脚本（每个类一个文件）开头写一个长长的包含文件的列表。\n\n在软件开发的系统中，不可能把所有的类都写在一个PHP文件中，当在一个PHP文件中需要调用另一个文件中声明的类时，就需要通过include把 这个文件引入。不过有的时候，在文件众多的项目中，要一一将所需类的文件都include进来，是一个很让人头疼的事，所以我们能不能在用到什么类的时 候，再把这个类所在的php文件导入呢？这就是我们这里我们要讲的"],[1,7,"类。"],[1,9,"## __autoload()\n\n在 PHP 5 中，可以定义一个 __autoload()函数，它会在试图使用尚未被定义的类时自动调 用，通过调用此函数，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类， __autoload()函数接收的一个参数，就是你想加载的类的 类名，所以你做项目时，在组织定义类的文件名时，需要按照一定的规则，最好以类名为中心，也可以加上统一的前缀或后缀形成文件名，比如 xxx_classname.php、classname_xxx.php以及就是classname.php等等。\n\n本例尝试分别从 MyClass1.php 和 MyClass2.php 文件中加载 MyClass1 和 MyClass2 类\n\n```php\n1\t<?php\n2\tfunction __autoload($classname)\n3\t{\n4\t    require_once $classname . '.php';\n5\t}\n6\n7\t//MyClass1类不存在时，自动调用__autoload()函数，传入参数”MyClass1”\n8\t$obj = new MyClass1();\n9\n10\t//MyClass2类不存在时，自动调用__autoload()函数，传入参数”MyClass2”\n11\t$obj2 = new MyClass2();\n12\t?>\n\n```\n\n## spl_autoload_register\n\n尽管 __autoload() 函数也能自动加载类和接口, 但是更建议使用 `spl_autoload_register()` 函数，因为它提供了一种更加灵活的方式来实现类的自动加载(同一个应用中 可以支持任意数量的加载器, 比如第三方库) 因此，不再建议使用 `__autoload()` 函数, 在以后的版本中它可能被弃用\n\n```php\n<?\nfunction loadprint( $class ) {\n $file = $class . '.class.php';\n if (is_file($file)) {\n require_once($file);\n }\n}\nspl_autoload_register( 'loadprint' );\n$obj = new PRINTIT();\n$obj->doPrint();?>\n```\n\n将__autoload换成loadprint函数。但是loadprint不会像__autoload自动触发，这时spl_autoload_register()就起作用了，它告诉PHP碰到没有定义的类就执行loadprint()。\nspl_autoload_register() 调用静态方法\n\n```php\n<?\nclass test {\n public static function loadprint( $class ) {\n $file = $class . '.class.php';\n if (is_file($file)) {\n  require_once($file);\n }\n }\n}\nspl_autoload_register( array('test','loadprint') );\n//另一种写法：spl_autoload_register( \"test::loadprint\" );\n$obj = new PRINTIT();\n$obj->doPrint();?>\n```\n\n如果同时用spl_autoload_register注册了一个类的方法和__autoload函数，那么，会根据注册的先后，如果在第一个注册的方法或函数里加载了类文件，就不会再执行第二个被注册的类的方法或函数。反之就会执行第二个被注册的类的方法或函数。\n\n```php\n<?php\nclass autoloader {\n  public static $loader;\n  public static function init() {\n    if (self::$loader == NULL)\n      self::$loader = new self ();\n    return self::$loader;\n  }\n  public function __construct() {\n    spl_autoload_register ( array ($this, 'model' ) );\n    spl_autoload_register ( array ($this, 'helper' ) );\n    spl_autoload_register ( array ($this, 'controller' ) );\n    spl_autoload_register ( array ($this, 'library' ) );\n  }\n  public function library($class) {\n    set_include_path ( get_include_path () . PATH_SEPARATOR . '/lib/' );\n    spl_autoload_extensions ( '.library.php' );\n    spl_autoload ( $class );\n  }\n  public function controller($class) {\n    $class = preg_replace ( '/_controller$/ui', '', $class );\n    set_include_path ( get_include_path () . PATH_SEPARATOR . '/controller/' );\n    spl_autoload_extensions ( '.controller.php' );\n    spl_autoload ( $class );\n  }\n  public function model($class) {\n    $class = preg_replace ( '/_model$/ui', '', $class );\n    set_include_path ( get_include_path () . PATH_SEPARATOR . '/model/' );\n    spl_autoload_extensions ( '.model.php' );\n    spl_autoload ( $class );\n  }\n  public function helper($class) {\n    $class = preg_replace ( '/_helper$/ui', '', $class );\n    set_include_path ( get_include_path () . PATH_SEPARATOR . '/helper/' );\n    spl_autoload_extensions ( '.helper.php' );\n    spl_autoload ( $class );\n  }\n}\n//call\nautoloader::init ();\n?>\n```\n\n注意 :\n\n如果你的电脑大小写敏感，调用spl_autoload_register方法需要注意，他会把类名自动变为小写的。你的文件名称应该是全部小写的才行。"]],[0,11],[3359,3359]]]],null,"mac@macdeMacBook-Pro.local"]]}